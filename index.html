<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>å¤§å‡‰å›½é›…è¨€è¯­è¨€è¾“å…¥æ³• - é€ å­—ç³»ç»Ÿ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { background:#0b0c2a; color:#fff; font-family:"Microsoft YaHei"; text-align:center; margin:0; padding:20px; }
    h2 { margin-bottom:10px; }
    #keyboard { display:flex; flex-wrap:wrap; justify-content:center; margin-top:20px; }
    .char-btn {
      background:#f0c000; color:#000; border:none; border-radius:8px;
      padding:12px; margin:6px; font-size:18px; min-width:60px; cursor:pointer;
      box-shadow:0 0 8px #f0c00066; transition:transform 0.1s ease;
    }
    .char-btn:hover { transform:scale(1.05); }
    #inputBox { margin-top:20px; padding:10px; width:90%; font-size:16px; border-radius:8px; border:none; }
    #backBtn { margin-top:20px; padding:8px 14px; background:#007bff; color:#fff; border:none; border-radius:6px; }
    canvas { background:#111; border:1px solid #f0c000; border-radius:6px; margin-top:20px; }
  </style>
</head>
<body>
  <h2>ğŸŒ  å¤§å‡‰å›½é›…è¨€è¯­è¨€è¾“å…¥æ³•</h2>
  <p>åœ¨ä¸‹é¢ç»˜åˆ¶å­—ç¬¦å¹¶ä¿å­˜ï¼Œå¯ä»¥éšæ„è¾“å…¥å­—ç¬¦ï¼Œæ˜¾ç¤ºå¯¹åº”çš„å­—å½¢ã€‚</p>

  <!-- è¾“å…¥æ¡† -->
  <input type="text" id="inputBox" placeholder="å¼€å§‹è¾“å…¥..." />

  <!-- ç»˜åˆ¶åŒºåŸŸ -->
  <canvas id="canvas" width="400" height="400"></canvas>

  <!-- æŒ‰é”®åŒº -->
  <div id="keyboard"></div>
  
  <!-- æŒ‰é’® -->
  <button id="saveBtn">ä¿å­˜å­—ç¬¦</button>
  <button id="loadBtn">åŠ è½½å­—ç¬¦</button>
  <button id="backBtn" onclick="window.location.href='#'">è¿”å›é¦–é¡µ</button>

  <script>
    // åˆå§‹åŒ–
    const chars = JSON.parse(localStorage.getItem("stargate_chars")) || { chars: [] };
    let currentStrokes = [];
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    // åˆå§‹åŒ–ç”»å¸ƒ
    function initCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#f0c000";
      ctx.lineWidth = 2;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
    }

    initCanvas();

    let drawing = false;
    let lastX = 0, lastY = 0;

    // å¼€å§‹ç»˜åˆ¶
    canvas.addEventListener('mousedown', function(e) {
      drawing = true;
      [lastX, lastY] = [e.offsetX, e.offsetY];
    });

    // ç»“æŸç»˜åˆ¶
    canvas.addEventListener('mouseup', function() {
      drawing = false;
      currentStrokes.push([]);
    });

    // ç»˜åˆ¶ç¬”ç”»
    canvas.addEventListener('mousemove', function(e) {
      if (!drawing) return;
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(e.offsetX, e.offsetY);
      ctx.stroke();
      lastX = e.offsetX;
      lastY = e.offsetY;
      currentStrokes[currentStrokes.length - 1].push({ x: e.offsetX, y: e.offsetY });
    });

    // ä¿å­˜å­—ç¬¦
    document.getElementById("saveBtn").addEventListener('click', function() {
      let charData = { strokes: currentStrokes };
      let jsonData = JSON.stringify(charData, null, 2);
      localStorage.setItem("currentChar", jsonData);
      alert('å­—ç¬¦å·²ä¿å­˜ï¼');
    });

    // åŠ è½½å­—ç¬¦
    document.getElementById("loadBtn").addEventListener('click', function() {
      let savedChar = localStorage.getItem("currentChar");
      if (!savedChar) return alert('æ²¡æœ‰ä¿å­˜çš„å­—ç¬¦ï¼');
      currentStrokes = JSON.parse(savedChar).strokes;
      initCanvas();
      currentStrokes.forEach(stroke => {
        stroke.forEach(p => {
          ctx.lineTo(p.x, p.y);
        });
      });
    });

    // é”®ç›˜æŒ‰é”®å±•ç¤º
    const inputBox = document.getElementById("inputBox");
    const keyboard = document.getElementById("keyboard");

    chars.chars.forEach(char => {
      const button = document.createElement("button");
      button.textContent = char.name;
      button.classList.add("char-btn");
      button.onclick = () => inputBox.value += char.name;
      keyboard.appendChild(button);
    });

    // ç›‘å¬è¾“å…¥æ¡†ï¼ŒåŠ¨æ€æ˜¾ç¤ºå­—ç¬¦
    inputBox.addEventListener("input", () => {
      const enteredText = inputBox.value;
      let matchedChar = chars.chars.find(char => enteredText.endsWith(char.name));
      if (matchedChar) {
        renderChar(matchedChar.strokes, 400, 400, ctx);
      }
    });

    // ç»˜åˆ¶å­—ç¬¦å‡½æ•°
    function renderChar(strokes, width, height, ctx) {
      if (!strokes || strokes.length === 0) {
        ctx.clearRect(0, 0, width, height);
        return;
      }

      let xs = [], ys = [];
      strokes.forEach(stroke => stroke.forEach(p => { xs.push(p.x); ys.push(p.y); }));
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);

      const padding = 5; // å¢åŠ è¾¹è·
      const charWidth = maxX - minX;
      const charHeight = maxY - minY;
      const scale = Math.min((width - 2 * padding) / charWidth, (height - 2 * padding) / charHeight) * 0.9;

      const offsetX = (width - charWidth * scale) / 2 - minX * scale;
      const offsetY = (height - charHeight * scale) / 2 - minY * scale;

      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = "#f0c000";
      ctx.lineWidth = 2;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      strokes.forEach(stroke => {
        if (stroke.length === 0) return;
        ctx.beginPath();
        ctx.moveTo(stroke[0].x * scale + offsetX, stroke[0].y * scale + offsetY);
        for (let i = 1; i < stroke.length; i++) {
          const prev = stroke[i - 1];
          const curr = stroke[i];
          const midX = (prev.x + curr.x) / 2;
          const midY = (prev.y + curr.y) / 2;
          ctx.quadraticCurveTo(prev.x * scale + offsetX, prev.y * scale + offsetY, midX * scale + offsetX, midY * scale + offsetY);
        }
        ctx.stroke();
      });
    }
  </script>
</body>
</html>
